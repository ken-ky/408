### 存储系统串讲笔记整理

#### 相关内容再整理

+ 虚拟地址（逻辑地址）：虚拟存储器将**主存或辅存**的地址空间统一编址（用于用户自由编程）【比主存更大的空间，**包括外存了**】

  + 只能使用回写法：缺页访问辅存数据代价大

+ 物理地址：实际的主存单元地址

+ 虚实地址转换：CPU使用虚地址时，先判断虚地址对应内容是否装入主存，在则进行地址转换；否则将包含**这个字的一页或一段**调入主存后**由CPU访问**；主存满时，使用替换算法置换主存中的交换块（页面）

  虚拟存储机制使用**全相联映射**，每个虚页面都可以任意放置在主存任意**空闲页**位置

  进行写操作时，使用**写回法**

  + 写命中策略

    + 全写法（直写法 write-through）：当CPU对Cache写命中时，必须把数据同时写入Cache和主存
      + 写缓冲：为了减少延迟，在主存和Cache间设置一个FIFO队列，缓解主存和Cache间速度不匹配问题

    + 写回法（write-back）：在全写法基础上给块增加了修改位，不再每次写Cache时都写主存，而是当块换出时写回主存

  + 写不命中策略

    + 写分配法（write-allocate）：每次写不命中都把此主存块调入Cache
    + 非写分配法（not-write-allocate）：只更新主存单元，不把主存块调回Cache

+ 几种虚拟地址的组成

  + 直接（Cache行号=主存块号 mod Cache行数）：标记+Cache行号+块内地址	
  + 全相联（按内容访问）：标记+块内地址
  + 组相联（Cache组号=主存块号 mod Cache组数）：标记+组号+块内地址

  直接映射相当于“一组相联映射”，仅设置一个比较器，而r组相联映射要设置r个比较器

+ 替换算法：

  + 随机替换
  + 先进先出替换
  + 近期最少使用（LRU）
  + 最不经常使用




+ 页式虚拟存储器（计组P138）
  + 虚拟页：主存和虚拟地址空间都被划分为大小相同页
  + 在**虚拟存储系统**中，**指令**给出的地址是**虚拟地址**，因此当CPU执行指令时，要先将虚拟地址转换为主存物理地址（为了从**主存**取指令和数据）
  + 此时，**VA**分为两个字段：**虚页号**（高位）和**页内偏移地址**（低位，实际大小），PA分为**物理页号**和**页内偏移地址**（实际大小、并非是地址位数）【因为生成物理地址时，页内偏移量不会改变，字节为单位】
+ Cache

  + 使用SRAM实现
  + 表项组成：

    + 直接相联：虚拟页号低位作为Cache行号；高位为标记
    + 全相联：对应虚拟页号作为Cache标记
    + 组相联：虚拟页号低位作为Cache组号；高位为标记

+ 快表（TLB）
  + 使用**SRAM**实现，通常使用**全相联**和**组相联**方式
  + 表项由**页表表项内容**和**TLB标记**组成
    + 全相联：对应表项虚拟页号作为TLB标记
    + **组相联：虚拟页号低位部分作为TLB组的组号；虚拟页号高位部分作为TLB标记**
+ 不同：Cache缺失（不在Cache内）由硬件完成，缺页（不在物理内存内）由软件完成，OS通过“缺页异常处理程序”实现；而TLB都可以





计算机<u>程序</u>$\Rightarrow$指令	数据：外存$\rightarrow$主存 $\rightarrow$CPU 进行渲染

APP：2GB数据+1GB指令 $\Rightarrow^{启动}_{OS}\Rightarrow$ 4GB（32位操作系统的VA[Max]，不一定把所有数据都调入）

​			使用数据时，假如资源未置入内存，就会发生缺页中断

​			**指令**通常由**操作码**和**地址码**构成，数据的虚拟位置由地址码字段提供（地址码=寻址方式+地址位置）

内存中的数据在物理内存中以**分页**、**离散**的方式存在，**操作系统**负责管理分出**物理的页表**项，其中的转换过程为**查页表**（虚拟地址转换为物理地址——取指令和执行指令$\to$指令位置存放在**PC（程序计数器）**中（指向**即将执行**的指令的**虚拟地址**，即当前执行指令的下一条））【**当前执行指令**存放在**IR（指令寄存器）**中】





**寄存器**中存放**虚拟地址**，转化为物理地址时经过MMU（memory management unit）转换为物理地址，物理地址置于MAR中，根据MAR访问主存

当前进程的页表（慢表）置于内存中，TLB（快表，硬件实现，MMU中的一部分），快表命中则可以直接得到物理地址；未命中则查内存页表，页表所在位置存储在“页表始址寄存器”（起始物理地址），查表地址：页表起始地址+页号+页表项长度=虚拟地址的物理页框号，同时也把这一地址加载到TLB中。

**进程控制块**记录了此**进程的页表始址**，当此进程即将上处理机运行时，那么页表始址寄存器就会得到新地址（转移至新页表）

页内偏移量直接由开始的低位地址得到，之后便可以拼接为物理地址



##### 查慢表

页表项大小由操作系统与**CPU**共同决定（主要与CPU决定），**地址=起始地址+页目录号（隐含）*页表项大小**，检查有效位（无缺页，缺页则根据内容存储地址查找外存）得到**页框号**，拼接页内偏移量得到物理地址。

一个页表在物理上必然是连续，类似于数组【有效位	页框号	页面对应外存地址】



补充TLB（查到表项放入TLB，图3）

TLB较快的原因（全相联）：比较器（异或门实现），8bit数据逐位异或，当且两个8bit数据相同时，其结果为0（或先非再与得到结果为1时，两数据相同）。当高位全部匹配，才会选中此页表项（标记位相与），实现了并行比较。

TLB命中时，不可能是缺页的，因为部分页在页表换出时，会将此页表项有效位置为0，并记录此页在外存的地址。另外，还会让OS将TLB内对应项有效位置为0



TLB未命中，查一级页表（回到查慢表，图5）



查二级页表

由CPU的虚拟地址得到一级页表页目录号，有一级页表起始地址，得到二级页表页框号（对应起始地址）又有虚拟地址的二级页目录号（无缺页）。

放入TLB的时候需要注意保存：一级页号、二级页号和对应的二级页框号……（为了起始地址能正常得到）



TLB未命中，查二级页表（图7）





Cache（全相联、组相联和直接映射）作用：将主存中最近经常被访问的块复制到Cache中

直接映射相当于一路组相联，每个Cache块只可能被存储到特定位置（主存Cache块数 mod Cache上的块数）

此次访问的数据放入MDR中

内存块大小=Cache块大小<<页（页框）大小



Cache行包括tag位、有效位、替换信息、Cache块等信息

由Cache块大小得到块内地址位数，由分组数确定组号所占位数（四路：每组占4行），剩余便是tag位

切换进程时，进程Cache有效位变化先全部置为0，之后缺页进行填充入Cache







### ep2 分析存储系统题目

+ 虚拟地址转换为物理地址

  + TLB
  + 查慢表（页表）

+ 物理地址访问Cache过程

  + Cache静态分析
    + Cache地址结构（物理地址拆分）
    + Cache行的完整构成：tag标记位、有效位、Cache数据块、替换位、脏位
  + Cache动态分析，物理地址访问序列：Cache命中率、替换次数
    + 直接给物理地址
    + 以数组元素形式$\to$访问一系列物理地址过程
    + 以汇编语言（机器级代码形式）给出

+ Cache地址结构（取决于映射方式）：

  + 直接映射：tag标记位+行号+块内地址
  + 组相联映射：tag标记位+组号+块内地址
  + 全相联映射：tag标记位+块内地址

  关注条件：物理地址位数（物理地址总位数）、Cache总行数（行号、组号）、Cache块大小（行号、块内地址）、**映射方式**（组相联映射：分路数（组号，分组数=总行数/分路数））

  【Cache总大小（所有Cache行大小总和）、Cache数据区总大小（所有Cache行中Cache块的大小总和）】



+ Cache行的完整构成：

  关注条件：

  + 物理地址位数（物理地址总位数）

  + Cache总行数（行号、组号）
  + Cache块大小（行号、块内地址）
  + **映射方式**（组相联映射：分路数（组号，分组数=总行数/分路数））
  + 写策略（直写法、回写法【脏位】）
  + 替换算法（随机、其它【替换信息位 多路组相联$\log_2(路数)$、直接映射 0位】）

  一定存在的位数：

  + tag标记位：1、2、3、4条件
  + 有效位：一定存在，1bit
  + 块内数据：Cache块大小

  其它位数：

  + 脏位：直写法0bit、写回法1bit
  + 替换信息位：
    + 随机替换0bit
    + 其它，受**映射方式**影响：直接0bit、**组相联**$\log_2(路数)$bit、全相联$\log_2(行数)$bit
  + 行号/组号（隐含，不占用bit）



+ TLB

  + 关注：
    + VA位数（**页号**、页内地址）、**虚页号**多少位
    + TLB映射方式：直接映射（存在TLB“抖动”情况，效率低），组相联映射（k路），全相联映射
    + 替换算法（同Cache替换算法）

  + 构成：
    + Tag：
      + **组相联**映射：虚页号=tag+组号（组号位数=$\log_2(组数)$）
      + 全相联映射：虚页号=tag
    + 有效位：一定存在，1bit
    + 页框号：一定存在，长度由物理页框数决定
    + 替换算法信息位：TLB替换算法（随机算法0bit，其它【组相联 $\log_2(路数)$、全相联 $\log_2(总行数)$】）