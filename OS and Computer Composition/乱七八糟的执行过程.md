### 乱七八糟执行过程

+ 五段式指令过程：

  取指、译码/取数、执行、访存、写回

  + 取指：PC->MAR, M(MAR)【给主存读信号】->MDR(指令)->IR；PC+“1”->PC
  + 译码：指令（变长和定长）分为操作数和地址码，在从主存取单元内容时【虚拟地址->物理地址（地址构成），MMU参与了此过程】，而此过程中又包括了多种寻址方式和页式存储等内容
  + 执行：控制器（PC+IR+CU）+ALU=CPU，完成相关运算，此过程包括了数字运算和表示方式、溢出判断和PSW的工作
  + 访存过程：此处可能会涉及重写快表【映射方式】等
  + 写回：几种写回方式（写命中和写不命中）

  调用类指令：

  + 压入函数的参数（一般在[ebp+8]、[ebp+12]等位置）
  + 局部变量（一般在[ebp-4]、[ebp-8]、[ebp-12]等位置）

  流水线问题：

  + 数据冒险：前写后读，访问了正在写的单元
  + 控制冒险：转移类指令导致预载两条指令不成功（阻塞3个时钟）

+ 系统调用处理：

  + 用户程序首先将系统调用号和所需参数压入堆栈
    + 调用实际调用指令，执行一个陷入指令，将CPU转换为核心态
    + 由硬件和操作系统内核程序保护被中断现场
    + 将PC、PSW及通用寄存器内容压栈
  + 分析系统调用类型，转入相应系统调用处理子程序
    + 系统配置了系统调用入口表，各表项与系统调用一一对应
    + 根据系统调用号找到系统调用子程序入口地址
  + 完成系统调用子程序执行后，恢复被中断的或设置新进程的CPU现场
    + 返回中断进程或新进程

+ 操作系统引导：

  + 激活CPU。激活的CPU读取ROM中的**boot程序**，将指令寄存器置为BIOS第一条指令，即开始BIOS第一条指令
  + 硬件自检。BIOS在**内存最开始空间**构建中断向量表，接下来的POST过程要使用中断功能。然后进行通电自检，检查硬件是否故障
  + 加载带有操作系统的硬盘。通电自检后，BIOS读取Boot Sequence（通过CMOS里保存的启动顺序，或者通过与用户交互的方式），将控制权交给**启动顺序排在第一位的存储设备**，然后CPU将该存储设备引导扇区的内容加载到内存中
  + 加载主引导记录（MBR）。硬盘以特定的标识符区分**引导硬盘**和非引导硬盘。如果发现一个存储设备不是可引导盘，就检查下一个存储设备。如无其它启动设备，就会死机。主引导MBR的作用是告诉CPU去硬盘的那个主分区去找操作系统
  + 扫描硬盘分区表，并加载硬盘活动分区。MBR包含硬盘分区表，硬盘分区表以特定的标识符区分活动分区和非活动分区。主引导记录扫描硬盘分区表，进而识别含有操作系统的硬盘分区（活动分区）。找到硬盘活动分区后，开始加载硬盘分区，**将控制权交给活动分区**
  + 加载分区引导记录（PBR）。读取活动分区第一个扇区，这个扇区称为分区引导记录（PBR），其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）
  + 加载启动管理器。分区引导记录搜索活动分区中启动管理器，加载启动管理器
  + 加载操作系统。将操作系统的**初始化程序**加载到**内存**中执行



+ 同步与互斥：

+ 进程调度：

  + 进程创建与销毁（通过创建和销毁PCB来进行）
  + **OS调度**某个进程运行前，要从该进程PCB中查出其现行状态及优先级
  + 在调度某个进程后，根据其PCB中中所保存的CPU状态信息，恢复现场（调入数据之类）
  + 进程在运行过程中，当需要和之前合作的进程实现同步、通信和访问文件时，也需要访问PCB
  + 当进程因为某种原因暂停，有需要将**其断点的CPU环境保存在PCB**中

  