### 一堆指令的执行

#### 重要概念回顾

+ 一条指令由n bit组成：操作码（指明动作）+操作数
  + 操作数：0~n个
    + 寻址方式：找到操作数，来自寄存器、主存和立即数
    + 形式地址：指令执行时要转为有效地址EA
  + 指令长度：
    + 定长：每次PC+“1”，固定移动偏移地址
    + 不定长：PC+“1”，移动距离不固定
  
+ 定长操作码和扩展操作码（自学）

  + 原则：不允许短码是长码的前缀；各指令操作码不允许重复
  + 操作码位数随地址数增加而减少

+ 寻址方式：
  + 有效地址：EA（[主存地址]）
  
  + 寻找（数据寻址【寻找操作数据】、指令寻址（顺序、跳跃）【找下一条执行指令，在主存中找】）
  
    + 对于转移指令JMP A，若指令地址为X，且占2B，则在取出该指令后，PC值增2，即(PC)=X+2，这样在执行完指令后自动跳转到**X+2+A**地址继续执行
  
  + 常见寻址方式：
    + 隐含寻址：程序指定（如：ret指令无操作数，在栈内找到程序返回地址）
  
    
  
    此部分为数据寻址：
  
    + 立即寻址：操作数在指令内
    + **直接寻址**：操作数在主存当中，给出了访存地址（主存）
    + 一次间接寻址：访两次存
    + **寄存器寻址**：指明寄存器编号，操作数在其中
    + **寄存器间接一次寻址**：寄存器中保存了操作数的地址
  
    
  
    + **相对寻址**：【转移类指令】修改PC值 EA=(PC)+A（要进行位扩展**对齐虚拟地址**进行处理【0扩展、**补码**符号扩展】）
    + 基址变址：【多道程序】基址寄存器（BR）内容由OS或管理程序确定（内容不能直接修改），当作为通用寄存器被选时为BX
    + 变址寻址：【循环程序】**数组元素访问**，起始地址+偏移量
    + 堆栈寻址：在栈内找到数据（ebp 栈底指针，esp 栈顶指针，隐含了操作数在SP内【入栈和出栈时都有自加自减】）
      + 压栈：压入函数的参数（一般在[ebp+8]、[ebp+12]等位置）、局部变量（一般在[ebp-4]、[ebp-8]、[ebp-12]等位置）
  
  
  
  + 常见寻址方式对比：（不包括取指阶段）
  
  | 寻址方式               | 有效地址                  | 访存次数及过程              |
  | ---------------------- | ------------------------- | --------------------------- |
  | 隐含寻址               | 程序指定                  | 0                           |
  | 立即寻址               | A即是操作数               | 0                           |
  | 直接寻址               | EA=A                      | 1                           |
  | 一次间接寻址           | EA=(A)                    | 2                           |
  | 寄存器寻址             | EA=$R_i$                  | 0                           |
  | 寄存器间接寻址（一次） | EA=$(R_i)$                | 1                           |
  | 相对寻址               | EA=(PC)+A                 | 1                           |
  | 基址寻址               | EA=(BR)+A                 | 1                           |
  | 变址寻址               | EA=(IX)+A                 | 1                           |
  | 堆栈寻址               | 入栈\出栈时EA确定方式不同 | 硬堆栈不访存，软堆栈访存1次 |
  
  
  
+ 数据存放和对齐方式：
  + 对齐（按边界、不按边界）
  + 大端（大地址放高地址）和小端
  
+ CISC和RISC显著区别：
  + 指令字是否定长：定长（RISC 精简指令集）
  + 除了Load和Store外，是否还有其它指令可访存（无则为RISC）



#### 解题

+ 观察是否有注释：x86不会给太多注释
+ 观察指令长度是否固定：x86为CISC（不固定长度），MIPS为RISC（指令长度固定）
+ 观察寄存器名：x86寄存器（eax、ebx、ecx、edx），MIPS寄存器（R[0]、R[1]、…）





#### 基于x86汇编语言

（无注释）

+ 题目代码段组成：行号+机器指令+虚拟地址+ 汇编代码
+ 判断代码段内是否有分支（cmp jxxx）、循环（jxxx loop）、函数调用（call ret）、函数调用参数、定义局部变量

##### 书上的汇编指令介绍

+ 不同系统下的汇编指令格式（P184）





#### 基于MIPS/RISC-V指令

+ 会给注释，基于C语言——高级语言程序与机器级代码之间的对应（2022）

  + 编译器、汇编器、链接器的基本概念

  + 选择结构的机器级表示（**cmp jmp指令**）

  + 循环结构语句的机器级表示（**cmp jmp指令**）

  + 过程（函数）调用对应的机器级表示（**call ret指令**）

+ 结合指令流水线





#### 再整理书上概念

+ 指令系统是指令集体系结构（ISA）中最核心的部分
+ ISA规定内容：
  1. 指令格式（寻址方式、操作数类型）
  2. 操作数类型，操作数寻址方式，大小端问题
  3. 程序可访问的寄存器（编号、个数、位数），存储空间大小和编址方式
  4. 指令执行过程的控制方式（程序计数器、条件码定义）



+ **机器指令**：指示计算机执行某种操作的命令，CPU可直接执行的（最小功能单位）

+ **机器字长**：CPU进行一次整数运算所能处理的二进制数据位数
+ **指令字长**：一条指令所包含的二进制代码位数，取决于操作码长度、地址码长度和地址码个数
  + 指令字长与机器字长没有固定关系（长短无关系）
  + 指令长度等于机器字长的指令为单字长指令（倍数）【长短倍数影响存取周期，双字长指令需要两个存取周期访存获得】
  + 主存通常按字节编址$\Rightarrow$指令字长通常为字节整数倍



+ 指令周期：用若干机器周期表示
  + 时钟周期：一般是CPU时钟频率（主频）倒数，完成一次微操作所需时间，**CPU操作基本单位**，节拍
  + 机器周期：包含若干个时钟周期，一般等于**从内存里面读取一条指令的最短时间**（与数据通路相关）
  + 每个指令周期内**机器周期数可能不等**，每个机器周期内**节拍数可能不等**
+ 一般的，一条指令要经历取址周期、间址周期、执行周期和中断周期（有的指令不会经过所有步骤）





+ 微程序：将每条机器指令编写成一个微程序；
  + 可以将**同节拍**的一些**微指令合并为微程序**，将**一个指令包含的微指令合并为一个微程序**
+ 微命令：构成控制序列最小单位（像是控制门的电位信号这样的）
  + 微程序控制的计算机中，控制部件向执行部件发出的**各种控制命令**称为微命令
    + 执行部件收到微命令的操作称为微操作【**微命令与微操作一一对应**】
+ 微指令与微周期
  + 微指令是若干微命令的集合
  + 微周期是指从控制存储器中取出并执行一条微指令所需的全部时间



【个人感觉不会直接考概念的，而是应用】

+ 微指令的编码方式：编码目标是保证速度条件下尽量缩短微指令字长
  + 直接编码（控制）方式：无需译码，微指令操作控制字段每一位都代表了一个**微命令**（门信号）
  + **字段直接编码方式**：
    + 互斥性微命令分在同一段，相容性微命令分在不同段
    + 每个小段信息位不能太多
    + 一般每个小椴还要留出状态，表示本字段不发出任何微命令（对应0的编码处）
  + 字段间接编码方式（隐式）：不靠字段直接译码，而是由另一字段某些微命令来解释

+ 微指令的地址形成方式：
  + 微指令后继地址（**下地址**）字段指出
  + 根据机器指令操作码形成
  + 增量计数：PC值增加
  + 由各种标志位决定（条件转移）
  + 硬件直接产生（如取值周期和调用）





+ 微指令格式
  + 水平型微指令：一条水平型微指令定义并执行多个并行操作微命令
  + 垂直型微指令：一条垂直型微指令通常只能定义并执行一种微命令（条数多）
  + 混合型：在垂直型基础上增加一些不太复杂的并行操作

+ 多地址指令：
  + 零地址：
    + 无地址：空操作、停机、关中断
    + 隐含：堆栈运算
  + 一地址：
    + 1地址：自增、自减、取反、求补、移位【三次访存：取指、读A1和写A1】
    + 隐含：另一操作数由ACC（累加器提供，如乘法）【两次访存：取指和读A1】
  + 二地址：【这里开始操作码占8位】
    + 算数、逻辑运算【四次访存：取指、读A1、读A2和**写A1**】
  + 三地址：
    + A3作为结果储存处【四次访存：四次访存：取指、读A1、读A2和**写A3**】
  + 四地址：
    + A4作为下一地址跳转【四次访存：四次访存：取指、读A1、读A2和**写A3**】
+ 扩展操作码（P158）
  + 原则：
    + 不允许短码为长码前缀
    + 各指令操作码不能重复