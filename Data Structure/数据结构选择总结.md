+ 广义表是一种非线性的数据结构。但如果广义表的每个元素都是原子，它就变成了线性表。

+ 数据结构是一门研究……关系和操作

+ 抽象数据类型：数据对象、数据关系和基本操作

+ 1、正确性：满足具体问题的解，基本目标。

  2、可读性：有利于人去理解算法。

  3、健壮性：输入非法数据，能适当做出处理，不产生莫名其妙的输出。

  4、高效性：包括时间的高效性和空间的高效性。

+ 树形：一对多

  图状：多对多

  集合：无，点与点

  线性：一对一

+ 循环链表就是将链表的最后一个结点指向链表头结点(或第一个结点)，即p-＞next=head

+ 数据项：构成数据元素的**不可分割**的**最小单位**



#### 树

+ 树

  + **树的节点数n=所有节点度数+1**
    + 子树分支数+根节点=所有节点
  + 度为m的树，第i层至多有$m^{i-1}$个节点
    + 祖先度均为m
  + **高度为h的m叉树有$h+m-1\leq n\leq(m^h-1)/(m-1)$个节点**
    + 度为m、具有n个节点的树最小高度为$h=\log_m{(n(m-1)+1)}$
    + 度为m、具有n个节点的树最大高度为$h=n-m+1$
  + 除了根节点外，任何结点**至少**有 ⌈m/2⌉个分叉，即**至少**含有  ⌈m/2⌉ − 1个关键字

  树转换二叉树，左孩子右兄弟

+ 二叉树

  + 非空二叉树的叶节点数=度为2节点数+1
  + 非空二叉树第k层**最多**有$2^{k-1}$个节点
  + 高度为h的二叉树至多有$2^h-1$个节点（满二叉树）
  + 顺序存储情况，2i处为左孩子，2i+1为右孩子

+ 二叉排序树（二叉查找树）

  + n个不同节点构造的**二叉查找树形态**（卡特兰数）：$f(n)=\frac{2n!}{n!(n+1)!}$
  + 二叉排序树不一定是AVL

+ 二叉平衡树（AVL）

  + **构建h层最少所需节点**（递推关系）：$n_0=0,n_1=1,...,n_{h}=n_{h-2}+n_{h-1}+1$

  + 红黑树

    + 从根到叶节点的最长路径不大于最短路径的2倍

    + 有n个内部节点的红黑树高度$h\leq 2\log_2(n+1)$

    + 新插入红黑树的节点初始着红色

      

    + 一棵高为h的红黑树，黑高一定不小于h/2

    + 红黑树节点数$n\geq 2^{h/2}-1\Rightarrow h\leq2\log_2(n+1)$

  + B树

    + n个关键字必有n+1个叶节点
    + n个关键字的高度满足：$\log_m(n+1)\leq h\leq\log_{\lceil m/2\rceil}(\frac{n+1}{2})+1$【**除了h为2的情况需要讨论根子树为2**】
      + 每个节点可具有几个关键字：$\lceil m/2\rceil-1\leq k\leq m-1$【**除了根节点可以最少只有一个关键字**】

  + B+树

    + 结点的子树个数与关键字个数相等
    + 非叶根节点至少有两棵子树，其他每个分支节点**至少**有$\lceil m/2\rceil$棵子树

+ 满二叉树

+ 完全二叉树





#### 查找

+ 平均查找长度ASL

+ 散列表
  + 填装因子：$元素个数/表长$，表示冲突可能性大小
  + “堆积”（聚集）：本来非同义词是不会堆积的，只是因为开放地址法解决两个同义词冲突时提前把非同义词的哈希地址给提前占用了，产生堆积的现象是由**非同义词之间发生的冲突**引起的，（平方探测不易发生堆积）
    + 堆积现象**直接影响**了平均查找长度
  + **平均查找长度不依赖于表内元素或者表长，而是填装因子**
    + 影响其查找长度的有装填因子、散列函数和冲突解决策略
  + 平均查找长度问题：
    + 失败：
      + 查找遇到删除位时，不计入查找次数就失败
      + 遇到空位时，计入查找次数后失败

   

#### 排序

+ 内部排序
  + 对任意n个关键字排序的比较次数：$l\geq\lceil\log_2(n!) \rceil$
+ 外部排序
  + $h-1=\lceil \log_kr\rceil=S$（S为归并趟数，r个初始段，k路归并）