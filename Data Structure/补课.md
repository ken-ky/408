#### 队列

+ 循环队列：为了解决顺序结构下的队列”假溢出“
  + 初始：`Q.front=Q.rear=0`
  + 入队：`Q.rear=(Q.rear+1)%MaxSize;`
  + 出队：`Q.front=(Q.front+1)%MaxSize;`
  + 判队满：
    + 牺牲一个元素作为标志，`(Q.rear+1)%MaxSize==Q.front`
    + 增设`size`成员
    + 增设`tag`作为判断是队满还是队空



#### 查找

+ 二叉排序树（BST）：左<根<右，中序为递增数列（子树节点与根节点也是如此）
  + $ASL_{min}=[\log_2n]+1$
  + 删除：
    + 被删节点有左右子树时，（直接后继）右子树中值最小节点来替代根【右的最左下】，或者（直接前驱）左的最右下
  + 查、插、删：$O(n)$

+ 二叉平衡树（AVL树）：二叉树平衡因子不超过1【以查为主】
  + 平衡因子：左子树高 - 右子树高
  + LL/RR/LR/RL调整（P298）：每次列出各层节点高度（空节点为0，左右子差值为2的节点旋转，左小旋左，重复至平衡，此节点的空下子树插到另一侧的最右下或最左下）
  + 查、插、删：$O(\log_2n)$

+ 红黑树（RBT）：是二叉排序树

  + 目的：为了避免插入或删除元素破坏平衡，插入和删除开销不会破坏“红黑特性”，调整在常数时间内
  + 考法【定义和性质（选择）、插入（手绘过程）】
    + 定义：节点值、左右孩子、父指针、颜色（红/黑）
    + 约束：
      + 根和叶节点（叶节点为空值而非数）都是黑色
      + 不存在两个相邻红色节点
      + 对每个节点出发到达某一叶节点的经过黑节点数量相同【黑高】
    + 性质：
      + 根节点到叶节点最长路径不大于最短路径的2倍
      + 有n个内部节点的红黑树高度$h\leq 2\log_2(n+1)$
      + 若根节点黑高为h，内部结点数最少有$2^h-1$（全黑）
  + 查、插、删：$O(\log_2n)$

  ![](../../../../Typora/cache_img/红黑树插入.png)



+ B树

  + m阶B树是所有结点的平衡因子均等于0的m路平衡查找树

    + 叶子节点（失败节点）；终端节点（查找得到节点）

  + 保证查找效率策略约束：

    + 除了根节点外，任何节点至少有[m/2]个分叉（向上取整），即至少含有[m/2]-1个关键字
    + 对于任何一个节点，子树高度相同

  + 性质：

    + 每个节点至多有m棵子树，最多有m-1个关键字

    + 若根节点不是终端节点，则至少有两棵子树

    + 所有叶节点都出现在同一层，并且不带信息【高度一般不包括失败节点】

    + 对于n个关键字的m阶B树

      + 最小高度：让结点尽可能满，$n\leq(m-1)(1+m+m^2+...+m^{h-1})=m^h-1$，因此$h\geq\log_m(n+1)$

      + 最大高度：让各层的分叉尽可能少，根只有2个分叉，其它只有$[m/2]$个分叉

        + 各层节点至少有：1、2、$[m/2]$、...、$([m/2])^{h-2}$
        + n个关键字的B树必有n+1个叶子节点，则$n+1\geq2([m/2])^{h-1}$，即$h\leq\log_{[m/2]}\frac{n+1}{2}+1$

        对于h层的m阶B树包含关键字总数$n\geq 1+2(k^{h-1}-1),\space k=[m/2]$

  + 插入：节点关键字个数$[m/2]-1\leq n\leq m-1$

    + 插入最底层终端，达到上限时就提中间元素到父节点，并且分裂成两个节点
    + 提父节点时，插入到当前节点分支的右边位置
    + 父节点超上限时，父节点分裂

  + 删除：

    + 终端节点，直接删除
    + 非终端，找其直接前驱（左侧指针的最右下）或者后继（右侧指针的最左下）
    + 合并，节点内关键字低于合法值



+ B+树：对于m阶的B+树
  + 约束：
    + 每个分支最多有m个子树
    + 非叶节点至少有2棵子树，其它都要至少有[m/2]棵子树
    + 节点子树个数与关键字个数相等
    + 叶节点包含**全部关键字**及指向相应记录的指针，相邻叶节点顺序相互连接【支持顺序查找】
    + 每层节点保留了子分支的最大值
  + 实际意义：高度越高，读磁盘次数越多，时间越久



+ 散列表（Hash）
  + 拉链法：设置一个p长度的散列表，每个表元素都对应了一个链表，链表保存了链表头地址
  + 开放定址法：如果发生冲突，则给元素找另外的空闲地址
    + 需要设置一种方法来探测空余空间：
      + 线性探测法：$d_i=0,1,2,3,...,n-1$
        + 设表长为m，探测所有元素，最多发生m-1次冲突
      + 平方探测法：$d_i=0^2,1^2,-1^2,2^2,...,k^2,{k-1}^2\space k\leq m/2$
        + 若表长m是可以表示为4j+3的素数，则可以探测到所有位置
      + 双散列法：$d_i=i\times Hash_2(key)$，使用两个散列函数，通过第一个散列函数$H(key)$得到地址发生冲突时，i为冲突次数：$H_i=(H(key)+i\times Hash_2(key))\%m$
        + 双散列法未必能探测到散列表的所有位置，若$Hash_2(key)$计算得到的值与散列表表长m互质，就能保证双散列可以探测所有元素
      + 伪随机序列法：人为设置伪随机序列
  + 删除元素：
    + 开放地址法时删除元素需要进行逻辑删除，设置一个删除标记
    + 可以不定期的整理散列表，并且使得逻辑删除的部分可以被作为添加元素部分





#### 排序

+ 算法稳定性：在经历了不同排序算法之后其结果仍然相同，则称此种算法稳定（不能衡量此算法的优劣）

+ 内部排序：排序期间元素全部存放在内存中的排序，一般其要经过**比较**和**移动**，时间复杂度取决于比较和移动次数
  + 插入排序
  + 交换排序
  + 选择排序
  + 归并排序
  + 基数排序（不基于比较）



+ 堆（Heap）：连续存储的数组，但是逻辑上为**顺序存储**的树，节点i的左孩子为2i，右孩子为2i+1
  + 大根堆：根$\geq$左、右（小根堆）
  + 插入新元素：
    + 放入堆底，与父节点比较（比父小则互换）
  + 删除元素：
    + 让堆底元素与其交换，重复下坠过程【两个孩子时，需要对比两次】



+ 外部排序：排序期间，元素不能全部置于内存，而是必须在排序过程中根据要求不断在内、外存之间进行移动
  + 多路归并排序
    + 优化：
      + 增加归并路数k代价：
        + 增加相应的输入缓冲区
        + 每次从k个归并段中选一个最小元素需要k-1次关键字对比
      + 减少初始归并段数量r